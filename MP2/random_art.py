# -*- coding: utf-8 -*-
"""
Random_art.py
Using Python's random, math, PIL, nested lists, and recursion to generate computational art
@author: SelinaWang, adapted from amonmillner work
@course: SoftwareDesignFall2015
@last midified: Tue Oct 13, 2015
"""

from random import randint, choice
from math import sin, cos, pi, tan, sqrt, frexp
from PIL import Image

def build_random_function(min_depth, max_depth):
	""" Using recursion to generate a random function of depth inbetween the min and max depths
	"""
	# inputs: min_depth (int), minimum amount of nesting
	#         max_depth (int), maximum amount of nesting
	# output: func (nested lis), generated function
	
	depth = randint(min_depth,max_depth)

	def random_function(number):
		# Once reach depth = 1, return a variable
		if number == 1:
			return [choice(["x","y"])]

		# Choose between the list of functions
		rand_func = randint(0,7)
		if rand_func == 0:
			return ['abs',random_function(number-1)]
		elif rand_func == 1:
			return ['cos_pi',random_function(number-1)]
		elif rand_func == 2:
			return ['sin_pi',random_function(number-1)]
		elif rand_func == 3:
			return ['sqrt',random_function(number-1)]
		elif rand_func == 4:
			return ['diff',random_function(number-1),random_function(number-1)]
		elif rand_func == 5:
			return ['ave',random_function(number-1),random_function(number-1)]
		elif rand_func == 6:
			return ['prod',random_function(number-1),random_function(number-1)]
		elif rand_func == 7:
			return ['frexp',random_function(number-1)]
		elif rand_func == 8:
			return ['x',random_function(number-1),random_function(number-1)]
		elif rand_func == 9:
			return ['y',random_function(number-1),random_function(number-1)]	

	func = random_function(depth)
	return func


def evaluate_random_function(f, x, y):
	""" Evaluate given function at coordinate (x,y) using recursion
	"""
	# inputs: f (function), random function generated by build_random_function
	#         x (int), remapped x coordinate of a pixel
	#		  y (int), remapped y coordinate of a pixel
	# output: evaluated (int), evaluated function at (x,y)

	def evaluate_func(next_func):

		if next_func[0] == 'x':
			return x
		elif next_func[0] == 'y':
			return y

		elif next_func[0] == 'abs':
			return abs(evaluate_func(next_func[1]))
		elif next_func[0] == 'cos_pi':
			return cos(pi*evaluate_func(next_func[1]))
		elif next_func[0] == 'sin_pi':
			return sin(pi*evaluate_func(next_func[1]))
		elif next_func[0] == 'sqrt':
			return sqrt(abs(pi*evaluate_func(next_func[1])))
		elif next_func[0] == 'diff':
			return evaluate_func(next_func[1])-evaluate_func(next_func[2])
		elif next_func[0] == 'ave':
			return (evaluate_func(next_func[1])+evaluate_func(next_func[2]))/2.0
		elif next_func[0] == 'prod':
			return evaluate_func(next_func[1])*evaluate_func(next_func[2])
		elif next_func[0] == 'frexp':
			return frexp(evaluate_func(next_func[1]))[0]
		elif next_func[0] == 'x':
			return evaluate_func(next_func[1])
		elif next_func[0] == 'y':
			return evaluate_func(next_func[2])

	evaluated = evaluate_func(f)
	return evaluated


def remap_interval(val, input_interval_start, input_interval_end, output_interval_start, output_interval_end):
	""" Maps the input value (int/float) that is in the interval [input_interval_start (int), input_interval_end (int)]
		to the output interval [output_interval_start (int), output_interval_end (int)].  The mapping
		is an affine one (i.e. output = input*c + b).
		Output: (int/float) 
	"""
 
	input_range = input_interval_end - input_interval_start
	output_range = output_interval_end - output_interval_start
	ratio = (val-input_interval_start) / float(input_range)
	output = output_interval_start + ratio*output_range
	return output


def create_image(min_depth,max_depth,size_x,size_y,filename):
	'''Creates a png image and save it under the given file name
	'''
	# inputs: min_depth (int), minimum amount of nesting
	#         max_depth (int), maximum amount of nesting
	#		  size_x (int), image x dimension
	#		  size_y (int), image y dimension
	#		  filename (string), given filename to store the image under

	red = build_random_function(min_depth,max_depth)
	green = build_random_function(min_depth,max_depth)
	blue = build_random_function(min_depth,max_depth)

	new_image = Image.new("RGB",(size_x,size_y))
	pixels = new_image.load()

	for i in range(size_x):
		for j in range(size_y):
			i_remap = remap_interval(i,0,size_x-1,-1,1)
			j_remap = remap_interval(j,0,size_y-1,-1,1)

			r_val = evaluate_random_function(red,i_remap,j_remap)
			g_val = evaluate_random_function(green,i_remap,j_remap)
			b_val = evaluate_random_function(blue,i_remap,j_remap)

			r_remap = int(remap_interval(r_val,-1,1,0,255))
			g_remap = int(remap_interval(g_val,-1,1,0,255))
			b_remap = int(remap_interval(b_val,-1,1,0,255))

			pixels[i,j] = (r_remap,g_remap,b_remap)

	new_image.save(filename)


if __name__ == '__main__':

	for i in range(10):
		create_image(2, 15, 350, 350, 'example' + str(i) + '.png')
